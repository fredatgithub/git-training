{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Git Training Introduction Welcome to Git Training! The purpose of this training material is to assist those interested in learning and imlementing Git and Version Control through simple, organized procedures based on the underlying principles and concepts that lay the foundation for Git. At its core, Git is a content tracking system. While it may seem complex due to the variety of options and commands available, Git is actually quite simple. Therefore, this guide aims to elaborate on the core concepts behind Git as well as their implementation in your current workflows rather than focusing on the commands and variety of options. Vocabulary Before we dive in, there are a few terms which should be mentioned first, since they\u2019ll appear repeatedly throughout this text: repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name. Flow The usual flow of events is this: After creating a repository, your work is done in the working tree. Once your work reaches a significant point \u2014 the completion of a bug, the end of the working day, a moment when everything compiles \u2014 you add your changes successively to the index. Once the index contains everything you intend to commit, you record its content in the repository. Here\u2019s a simple diagram that shows a typical project\u2019s life-cycle: With this basic picture in mind, the following sections shall attempt to describe how each of these different entities is important to the operation of Git. Continue to Getting Started","title":"Home"},{"location":"#git-training","text":"","title":"Git Training"},{"location":"#introduction","text":"Welcome to Git Training! The purpose of this training material is to assist those interested in learning and imlementing Git and Version Control through simple, organized procedures based on the underlying principles and concepts that lay the foundation for Git. At its core, Git is a content tracking system. While it may seem complex due to the variety of options and commands available, Git is actually quite simple. Therefore, this guide aims to elaborate on the core concepts behind Git as well as their implementation in your current workflows rather than focusing on the commands and variety of options.","title":"Introduction"},{"location":"#vocabulary","text":"Before we dive in, there are a few terms which should be mentioned first, since they\u2019ll appear repeatedly throughout this text: repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name.","title":"Vocabulary"},{"location":"#flow","text":"The usual flow of events is this: After creating a repository, your work is done in the working tree. Once your work reaches a significant point \u2014 the completion of a bug, the end of the working day, a moment when everything compiles \u2014 you add your changes successively to the index. Once the index contains everything you intend to commit, you record its content in the repository. Here\u2019s a simple diagram that shows a typical project\u2019s life-cycle: With this basic picture in mind, the following sections shall attempt to describe how each of these different entities is important to the operation of Git. Continue to Getting Started","title":"Flow"},{"location":"about/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"About"},{"location":"about/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"about/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"about/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"notes/","text":"Notes: Local Workflow: git init: put Git in this folder so that it keeps track of changes to files in this folder and subfolders Working Directory: the directory you\u2019re writing code in Staging Area: files are in the staging area if the changes in them will be included in the next save point Repository: everything Git is keeping track of git status: show me which files have been changed and which ones are ready to be committed git add filename.txt: include the changes to this file in the next commit git commit -m \u201ccommit message\u201d: wrap up all these changes and save them together with a short description of the changes git log: show a history of all commits git diff: show what is different from the last commit line by line git diff 234nod: show what is different between the commit 234nod and current state, line by line Remote Repository git remote add origin address-of-remote: make address-of-remote a new place to put my code and call it \u201corigin\u201d git push -u origin master: push my code to the location origin points to, on the master branch, and also in the future I will pull code from this same location Upstream: where I will pull code from in the future Origin: where I put backups or share my code git pull: grab code from another repository git fetch: grab code from another repository git push: save my history and changes in another location Fork: I want a GitHub repo that looks like someone else\u2019s repo Pull Request: I made some changes that I would like you to include in your repository, please accept them git clone: give me the code at this location Branching git branch: what are all my branches? or what are all the names of the different versions of my code? git branch feature: make a new branch/version of my code with the name feature git checkout feature: move to that branch/version of my code so I can make changes to that branch/version of my code master: the name of the branch which should be the official, working, well documented, version of my code git merge: combine the history of two branches so I can have the changes from both in one place Merge Conflict: Git does not know how to combine two histories and needs human assistance More Advanced Concepts Would not teach these early on in the process. HEAD git rebase git rm filename.txt git mv filename.txt otherfile.txt git rebase git cherry-pick git bisect git amend git reflog git blame Tips Have trainees install Git and make a GitHub/Bitbucket account ahead of time to save time. Anticipate Windows users and be prepared for the strange ways in which Git bash works differently. Partner students up so there are fewer different machines to worry about. Make sure the partners have the same operating system so that they do not learn Git in an environment they will never use again. If you are teaching an individual, give them a project to work on so they can use Git in context. It is harder to pick a project that would work for a group of people, and it will be hard to monitor all of them, of course. But if you can use a project, especially for teaching a single person, the process is a lot easier. Don\u2019t forget Build a context for your student before teaching commands by explaining the problem Git solves, drawing pictures, and using metaphors. When you teach the commands, try and explain them without using the name of the command in the explanation. Be choosey about what to teach right now and what they can learn later.","title":"Notes"},{"location":"notes/#notes","text":"","title":"Notes:"},{"location":"notes/#local-workflow","text":"git init: put Git in this folder so that it keeps track of changes to files in this folder and subfolders Working Directory: the directory you\u2019re writing code in Staging Area: files are in the staging area if the changes in them will be included in the next save point Repository: everything Git is keeping track of git status: show me which files have been changed and which ones are ready to be committed git add filename.txt: include the changes to this file in the next commit git commit -m \u201ccommit message\u201d: wrap up all these changes and save them together with a short description of the changes git log: show a history of all commits git diff: show what is different from the last commit line by line git diff 234nod: show what is different between the commit 234nod and current state, line by line","title":"Local Workflow:"},{"location":"notes/#remote-repository","text":"git remote add origin address-of-remote: make address-of-remote a new place to put my code and call it \u201corigin\u201d git push -u origin master: push my code to the location origin points to, on the master branch, and also in the future I will pull code from this same location Upstream: where I will pull code from in the future Origin: where I put backups or share my code git pull: grab code from another repository git fetch: grab code from another repository git push: save my history and changes in another location Fork: I want a GitHub repo that looks like someone else\u2019s repo Pull Request: I made some changes that I would like you to include in your repository, please accept them git clone: give me the code at this location","title":"Remote Repository"},{"location":"notes/#branching","text":"git branch: what are all my branches? or what are all the names of the different versions of my code? git branch feature: make a new branch/version of my code with the name feature git checkout feature: move to that branch/version of my code so I can make changes to that branch/version of my code master: the name of the branch which should be the official, working, well documented, version of my code git merge: combine the history of two branches so I can have the changes from both in one place Merge Conflict: Git does not know how to combine two histories and needs human assistance","title":"Branching"},{"location":"notes/#more-advanced-concepts","text":"Would not teach these early on in the process. HEAD git rebase git rm filename.txt git mv filename.txt otherfile.txt git rebase git cherry-pick git bisect git amend git reflog git blame","title":"More Advanced Concepts"},{"location":"notes/#tips","text":"Have trainees install Git and make a GitHub/Bitbucket account ahead of time to save time. Anticipate Windows users and be prepared for the strange ways in which Git bash works differently. Partner students up so there are fewer different machines to worry about. Make sure the partners have the same operating system so that they do not learn Git in an environment they will never use again. If you are teaching an individual, give them a project to work on so they can use Git in context. It is harder to pick a project that would work for a group of people, and it will be hard to monitor all of them, of course. But if you can use a project, especially for teaching a single person, the process is a lot easier.","title":"Tips"},{"location":"notes/#dont-forget","text":"Build a context for your student before teaching commands by explaining the problem Git solves, drawing pictures, and using metaphors. When you teach the commands, try and explain them without using the name of the command in the explanation. Be choosey about what to teach right now and what they can learn later.","title":"Don\u2019t forget"},{"location":"resources/","text":"Git Resources Websites Git Website About Documentation Downloads Community Pro Git Book Learning Branching Javascript Tutorial Online Atlassian Git Tutorials Git Immersion Guided Tour Code Academy: Learn Git Article: Better Documentation through Committ Messages Article: How to write Git Committ Messages Graphical User Interface's - GUI Git GUI Visual Studio Code Sourcetree GitHub Desktop GitKraken this is what I use RStudio SmartGit GitUp Fork git-cola Git-Ahead TortoiseGit Tower Sublime Merge Gitg Aurees GitAtomic and many others! Glossary repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name. Commands Concepts","title":"Resources"},{"location":"resources/#git-resources","text":"","title":"Git Resources"},{"location":"resources/#websites","text":"Git Website About Documentation Downloads Community Pro Git Book Learning Branching Javascript Tutorial Online Atlassian Git Tutorials Git Immersion Guided Tour Code Academy: Learn Git Article: Better Documentation through Committ Messages Article: How to write Git Committ Messages","title":"Websites"},{"location":"resources/#graphical-user-interfaces-gui","text":"Git GUI Visual Studio Code Sourcetree GitHub Desktop GitKraken this is what I use RStudio SmartGit GitUp Fork git-cola Git-Ahead TortoiseGit Tower Sublime Merge Gitg Aurees GitAtomic and many others!","title":"Graphical User Interface's - GUI"},{"location":"resources/#glossary","text":"repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name.","title":"Glossary"},{"location":"resources/#commands","text":"","title":"Commands"},{"location":"resources/#concepts","text":"","title":"Concepts"},{"location":"guide/0-introduction/","text":"Introduction Welcome to Git! The purpose of this training material is to assist those interested in learning and imlementing Git and Version Control through simple, organized procedures based on the underlying principles and concepts that lay the foundation for Git. At its core, Git is a content tracking system. While it may seem complex due to the variety of options and commands available, Git is actually quite simple. Therefore, this guide aims to elaborate on the core concepts behind Git as well as their implementation in your current workflows rather than focusing on the commands and variety of options. Vocabulary Before we dive in, there are a few terms which should be mentioned first, since they\u2019ll appear repeatedly throughout this text: repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name. Flow The usual flow of events is this: After creating a repository, your work is done in the working tree. Once your work reaches a significant point \u2014 the completion of a bug, the end of the working day, a moment when everything compiles \u2014 you add your changes successively to the index. Once the index contains everything you intend to commit, you record its content in the repository. Here\u2019s a simple diagram that shows a typical project\u2019s life-cycle: With this basic picture in mind, the following sections shall attempt to describe how each of these different entities is important to the operation of Git. Continue to Getting Started","title":"Introduction"},{"location":"guide/0-introduction/#introduction","text":"Welcome to Git! The purpose of this training material is to assist those interested in learning and imlementing Git and Version Control through simple, organized procedures based on the underlying principles and concepts that lay the foundation for Git. At its core, Git is a content tracking system. While it may seem complex due to the variety of options and commands available, Git is actually quite simple. Therefore, this guide aims to elaborate on the core concepts behind Git as well as their implementation in your current workflows rather than focusing on the commands and variety of options.","title":"Introduction"},{"location":"guide/0-introduction/#vocabulary","text":"Before we dive in, there are a few terms which should be mentioned first, since they\u2019ll appear repeatedly throughout this text: repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name.","title":"Vocabulary"},{"location":"guide/0-introduction/#flow","text":"The usual flow of events is this: After creating a repository, your work is done in the working tree. Once your work reaches a significant point \u2014 the completion of a bug, the end of the working day, a moment when everything compiles \u2014 you add your changes successively to the index. Once the index contains everything you intend to commit, you record its content in the repository. Here\u2019s a simple diagram that shows a typical project\u2019s life-cycle: With this basic picture in mind, the following sections shall attempt to describe how each of these different entities is important to the operation of Git. Continue to Getting Started","title":"Flow"},{"location":"guide/1-getting-started/","text":"Getting Started When first getting started with Git it is useful to first understand the core concepts and workflows related to Git and Version Control Systems. Here I will first look at those core concepts and workflows and then follow up with a more in-depth dive into the individual components that build the Version Control System. Core Concepts and Workflows At its core Git is merely a content magement system build off of comprehensive indexing the history, changes, and metadata surrounding the evolutionof those changes over time for a specific project, dataset, or directory of content. Distributed Version Control System It is important to realize that a distributed version control system is the backbone of the fundamental Git workflow. To understand further imagine separating your project into two main environments: The Dev Environment - This is where you work on your project locally and develop new code, data, functions, etc. The Remote or Server Environment - This is a remote repository that mirrors and tracks your development environment using Git. The Development Environment: Working Directory Staging Area and Index Local Repository Server / Remote Environment: Remote Repository Cloning When cloning a remote repository, the data from the remote repository travels to two areas: Working Directory Local Repository Making Changes There are two types of files in the working directory: Tracked: files that Git knows about. Untracked: files that have still not been added, so Git doesn\u2019t know about. Updating the Remote Repository As changes are ready in the working directory, they must be added in the staging area. When there is a set of changes with a single purpose in the staging area, it\u2019s the time to create a commit with a message about that purpose in the local repository. When there are one or several commits in the local repository ready to be shared with the rest of the world, they must be pushed to the remote repository. The core workflow for incorporating changes from local to remote is Add -> Commit -> Push : You can break down the different possible states of a file in the development environment into three main categories: Modified Staged Committed Additionally, it is useful to be familiar with these helpful utility commands: git diff - show the changes of a file in the working directory compared to what is currently on remote. git diff --staged - show the changes of a file in the staging area Updating the Development Environment When changes are made on the remote repository over time, either by yourself or collaborators, you will want to keep your local development environment up-to-date by fetching , pulling , and/or rebasing the remote repository with your local repository. A helpful way to think about this is imagining it working like cloud storage software such as Google Drive. When a file is updated on the cloud (i.e. the remote repository) the software sync's your local version of that file to stay up-to-date with the remote file. Similarly, Git keeps your local environment in sync by continuously watching and tracking changes to the remote repository, but will not automatically make the changes to your local repository for you. Fetching Fetching via git fetch pulls data from the remote repository to the local repository . Pulling When executing git pull , the data from remote repository travel to two areas: To local repository: fetch To working directory: merge Rebasing If you take care of the commit history, consider the use of git pull --rebase . Instead of fetch + merge, it consists of fetch + rebase. Your local commits will be replayed and you won\u2019t see the known diamond shape in commit history. Additional Concepts Stashing Branching Commit history Further Reading Pro Git Book Now lets take an in-depth look at git from the ground up by continuing to Git Deep Dive","title":"Getting Started"},{"location":"guide/1-getting-started/#getting-started","text":"When first getting started with Git it is useful to first understand the core concepts and workflows related to Git and Version Control Systems. Here I will first look at those core concepts and workflows and then follow up with a more in-depth dive into the individual components that build the Version Control System.","title":"Getting Started"},{"location":"guide/1-getting-started/#core-concepts-and-workflows","text":"At its core Git is merely a content magement system build off of comprehensive indexing the history, changes, and metadata surrounding the evolutionof those changes over time for a specific project, dataset, or directory of content.","title":"Core Concepts and Workflows"},{"location":"guide/1-getting-started/#distributed-version-control-system","text":"It is important to realize that a distributed version control system is the backbone of the fundamental Git workflow. To understand further imagine separating your project into two main environments: The Dev Environment - This is where you work on your project locally and develop new code, data, functions, etc. The Remote or Server Environment - This is a remote repository that mirrors and tracks your development environment using Git.","title":"Distributed Version Control System"},{"location":"guide/1-getting-started/#the-development-environment","text":"Working Directory Staging Area and Index Local Repository","title":"The Development Environment:"},{"location":"guide/1-getting-started/#server-remote-environment","text":"Remote Repository","title":"Server / Remote Environment:"},{"location":"guide/1-getting-started/#cloning","text":"When cloning a remote repository, the data from the remote repository travels to two areas: Working Directory Local Repository","title":"Cloning"},{"location":"guide/1-getting-started/#making-changes","text":"There are two types of files in the working directory: Tracked: files that Git knows about. Untracked: files that have still not been added, so Git doesn\u2019t know about.","title":"Making Changes"},{"location":"guide/1-getting-started/#updating-the-remote-repository","text":"As changes are ready in the working directory, they must be added in the staging area. When there is a set of changes with a single purpose in the staging area, it\u2019s the time to create a commit with a message about that purpose in the local repository. When there are one or several commits in the local repository ready to be shared with the rest of the world, they must be pushed to the remote repository. The core workflow for incorporating changes from local to remote is Add -> Commit -> Push : You can break down the different possible states of a file in the development environment into three main categories: Modified Staged Committed Additionally, it is useful to be familiar with these helpful utility commands: git diff - show the changes of a file in the working directory compared to what is currently on remote. git diff --staged - show the changes of a file in the staging area","title":"Updating the Remote Repository"},{"location":"guide/1-getting-started/#updating-the-development-environment","text":"When changes are made on the remote repository over time, either by yourself or collaborators, you will want to keep your local development environment up-to-date by fetching , pulling , and/or rebasing the remote repository with your local repository. A helpful way to think about this is imagining it working like cloud storage software such as Google Drive. When a file is updated on the cloud (i.e. the remote repository) the software sync's your local version of that file to stay up-to-date with the remote file. Similarly, Git keeps your local environment in sync by continuously watching and tracking changes to the remote repository, but will not automatically make the changes to your local repository for you.","title":"Updating the Development Environment"},{"location":"guide/1-getting-started/#fetching","text":"Fetching via git fetch pulls data from the remote repository to the local repository .","title":"Fetching"},{"location":"guide/1-getting-started/#pulling","text":"When executing git pull , the data from remote repository travel to two areas: To local repository: fetch To working directory: merge","title":"Pulling"},{"location":"guide/1-getting-started/#rebasing","text":"If you take care of the commit history, consider the use of git pull --rebase . Instead of fetch + merge, it consists of fetch + rebase. Your local commits will be replayed and you won\u2019t see the known diamond shape in commit history.","title":"Rebasing"},{"location":"guide/1-getting-started/#additional-concepts","text":"Stashing Branching Commit history","title":"Additional Concepts"},{"location":"guide/1-getting-started/#further-reading","text":"Pro Git Book Now lets take an in-depth look at git from the ground up by continuing to Git Deep Dive","title":"Further Reading"},{"location":"guide/2-deep-dive/","text":"Coming Soon.","title":"Deep Dive"},{"location":"guide/3-installation/","text":"Installing Git Note: This guide is meant for Windows 10 users. There are many ways one can go about installing Git on a Windows machine. Examples include: downloading the windows installer for your machine from The Git Website and running the installer locally, building from source , installing from command line or powershell, installing via make , or installing via a command line utility library such as scoop or chocolatey. How you install Git should be tailored to what you are comfortable with, which for most people is simply downloading the installer from Git's website and running it locally from your machine: Visit https://git-scm.com/downloads Click on Windows Select the installer based on your system's configuration: Operating System Portable or \"thumbdrive edition\" Full installation 64-bit Architecture 32-bit Architecture Some Notes: Note that this is a project called Git for Windows, which is separate from Git itself; for more information on it, go to https://gitforwindows.org . To get an automated installation you can use the Git Chocolatey package . Note that the Chocolatey package is community maintained. Another easy way to get Git installed is by installing GitHub Desktop. The installer includes a command line version of Git as well as the GUI. It also works well with PowerShell, and sets up solid credential caching and sane CRLF settings. We\u2019ll learn more about those things a little later, but suffice it to say they\u2019re things you want. You can download this from the GitHub Desktop website . Windows Installation Tips On windows you want to configure your setup slightly different from other OS's due to the usage of Windows Credential Manager, System and User Environment Variable Paths, and SSH/GPG integrations. Some tips to follow include: During installation do not select the option for using Windows Credential Manager as this brings annoyances later on which verifying credentials associated with any remote repository hosting platforms such as GitHub or BitBucket. Note I have not tried the NEW Cross-Platform version of the Git Credential Manager yet. Installation ScreenShots Here is a collage of each step and the settings I select when downloading/updating Git for Windows: Installing from Source Some people may instead find it useful to install Git from source, because you\u2019ll get the most recent version. The binary installers tend to be a bit behind, though as Git has matured in recent years, this has made less of a difference. If you do want to install Git from source, you need to have the following libraries that Git depends on: autotools, curl, zlib, openssl, expat, and libiconv. For example, if you\u2019re on a system that has dnf (such as Fedora) or apt-get (such as a Debian-based system), you can use one of these commands to install the minimal dependencies for compiling and installing the Git binaries: $ sudo dnf install dh-autoreconf curl-devel expat-devel gettext-devel \\ openssl-devel perl-devel zlib-devel $ sudo apt-get install dh-autoreconf libcurl4-gnutls-dev libexpat1-dev \\ gettext libz-dev libssl-dev In order to be able to add the documentation in various formats (doc, html, info), these additional dependencies are required: $ sudo dnf install asciidoc xmlto docbook2X $ sudo apt-get install asciidoc xmlto docbook2x Git Dependencies From the Git for Windows INSTALL guide: Git is reasonably self-sufficient, but does depend on a few external programs and libraries. Git can be used without most of them by adding the appropriate \"NO_<LIBRARY>=YesPlease\" to the make command line or config.mak file. - \"zlib\", the compression library. Git won't build without it. - \"ssh\" is used to push and pull over the net. - A POSIX-compliant shell is required to run some scripts needed for everyday use (e.g. \"bisect\", \"request-pull\"). - \"Perl\" version 5.8 or later is needed to use some of the features (e.g. preparing a partial commit using \"git add -i/-p\", interacting with svn repositories with \"git svn\"). If you can live without these, use NO_PERL. Note that recent releases of Redhat/Fedora are reported to ship Perl binary package with some core modules stripped away (see http://lwn.net/Articles/477234/), so you might need to install additional packages other than Perl itself, e.g. Digest::MD5, File::Spec, File::Temp, Net::Domain, Net::SMTP, and Time::HiRes. - git-imap-send needs the OpenSSL library to talk IMAP over SSL if you are using libcurl older than 7.34.0. Otherwise you can use NO_OPENSSL without losing git-imap-send. By default, git uses OpenSSL for SHA1 but it will use its own library (inspired by Mozilla's) with either NO_OPENSSL or BLK_SHA1. Also included is a version optimized for PowerPC (PPC_SHA1). - \"libcurl\" library is used by git-http-fetch, git-fetch, and, if the curl version >= 7.34.0, for git-imap-send. You might also want the \"curl\" executable for debugging purposes. If you do not use http:// or https:// repositories, and do not want to put patches into an IMAP mailbox, you do not have to have them (use NO_CURL). - \"expat\" library; git-http-push uses it for remote lock management over DAV. Similar to \"curl\" above, this is optional (with NO_EXPAT). - \"wish\", the Tcl/Tk windowing shell is used in gitk to show the history graphically, and in git-gui. If you don't want gitk or git-gui, you can use NO_TCLTK. - A gettext library is used by default for localizing Git. The primary target is GNU libintl, but the Solaris gettext implementation also works. We need a gettext.h on the system for C code, gettext.sh (or Solaris gettext(1)) for shell scripts, and libintl-perl for Perl programs. Set NO_GETTEXT to disable localization support and make Git only use English. Under autoconf the configure script will do this automatically if it can't find libintl on the system. - Python version 2.4 or later (but not 3.x, which is not supported by Perforce) is needed to use the git-p4 interface to Perforce. Installing a GUI Visit https://git-scm.com/download/gui/windows for a listing of options here. I also have a listing under resources .","title":"Installation"},{"location":"guide/3-installation/#installing-git","text":"Note: This guide is meant for Windows 10 users. There are many ways one can go about installing Git on a Windows machine. Examples include: downloading the windows installer for your machine from The Git Website and running the installer locally, building from source , installing from command line or powershell, installing via make , or installing via a command line utility library such as scoop or chocolatey. How you install Git should be tailored to what you are comfortable with, which for most people is simply downloading the installer from Git's website and running it locally from your machine: Visit https://git-scm.com/downloads Click on Windows Select the installer based on your system's configuration: Operating System Portable or \"thumbdrive edition\" Full installation 64-bit Architecture 32-bit Architecture Some Notes: Note that this is a project called Git for Windows, which is separate from Git itself; for more information on it, go to https://gitforwindows.org . To get an automated installation you can use the Git Chocolatey package . Note that the Chocolatey package is community maintained. Another easy way to get Git installed is by installing GitHub Desktop. The installer includes a command line version of Git as well as the GUI. It also works well with PowerShell, and sets up solid credential caching and sane CRLF settings. We\u2019ll learn more about those things a little later, but suffice it to say they\u2019re things you want. You can download this from the GitHub Desktop website .","title":"Installing Git"},{"location":"guide/3-installation/#windows-installation-tips","text":"On windows you want to configure your setup slightly different from other OS's due to the usage of Windows Credential Manager, System and User Environment Variable Paths, and SSH/GPG integrations. Some tips to follow include: During installation do not select the option for using Windows Credential Manager as this brings annoyances later on which verifying credentials associated with any remote repository hosting platforms such as GitHub or BitBucket. Note I have not tried the NEW Cross-Platform version of the Git Credential Manager yet.","title":"Windows Installation Tips"},{"location":"guide/3-installation/#installation-screenshots","text":"Here is a collage of each step and the settings I select when downloading/updating Git for Windows:","title":"Installation ScreenShots"},{"location":"guide/3-installation/#installing-from-source","text":"Some people may instead find it useful to install Git from source, because you\u2019ll get the most recent version. The binary installers tend to be a bit behind, though as Git has matured in recent years, this has made less of a difference. If you do want to install Git from source, you need to have the following libraries that Git depends on: autotools, curl, zlib, openssl, expat, and libiconv. For example, if you\u2019re on a system that has dnf (such as Fedora) or apt-get (such as a Debian-based system), you can use one of these commands to install the minimal dependencies for compiling and installing the Git binaries: $ sudo dnf install dh-autoreconf curl-devel expat-devel gettext-devel \\ openssl-devel perl-devel zlib-devel $ sudo apt-get install dh-autoreconf libcurl4-gnutls-dev libexpat1-dev \\ gettext libz-dev libssl-dev In order to be able to add the documentation in various formats (doc, html, info), these additional dependencies are required: $ sudo dnf install asciidoc xmlto docbook2X $ sudo apt-get install asciidoc xmlto docbook2x","title":"Installing from Source"},{"location":"guide/3-installation/#git-dependencies","text":"From the Git for Windows INSTALL guide: Git is reasonably self-sufficient, but does depend on a few external programs and libraries. Git can be used without most of them by adding the appropriate \"NO_<LIBRARY>=YesPlease\" to the make command line or config.mak file. - \"zlib\", the compression library. Git won't build without it. - \"ssh\" is used to push and pull over the net. - A POSIX-compliant shell is required to run some scripts needed for everyday use (e.g. \"bisect\", \"request-pull\"). - \"Perl\" version 5.8 or later is needed to use some of the features (e.g. preparing a partial commit using \"git add -i/-p\", interacting with svn repositories with \"git svn\"). If you can live without these, use NO_PERL. Note that recent releases of Redhat/Fedora are reported to ship Perl binary package with some core modules stripped away (see http://lwn.net/Articles/477234/), so you might need to install additional packages other than Perl itself, e.g. Digest::MD5, File::Spec, File::Temp, Net::Domain, Net::SMTP, and Time::HiRes. - git-imap-send needs the OpenSSL library to talk IMAP over SSL if you are using libcurl older than 7.34.0. Otherwise you can use NO_OPENSSL without losing git-imap-send. By default, git uses OpenSSL for SHA1 but it will use its own library (inspired by Mozilla's) with either NO_OPENSSL or BLK_SHA1. Also included is a version optimized for PowerPC (PPC_SHA1). - \"libcurl\" library is used by git-http-fetch, git-fetch, and, if the curl version >= 7.34.0, for git-imap-send. You might also want the \"curl\" executable for debugging purposes. If you do not use http:// or https:// repositories, and do not want to put patches into an IMAP mailbox, you do not have to have them (use NO_CURL). - \"expat\" library; git-http-push uses it for remote lock management over DAV. Similar to \"curl\" above, this is optional (with NO_EXPAT). - \"wish\", the Tcl/Tk windowing shell is used in gitk to show the history graphically, and in git-gui. If you don't want gitk or git-gui, you can use NO_TCLTK. - A gettext library is used by default for localizing Git. The primary target is GNU libintl, but the Solaris gettext implementation also works. We need a gettext.h on the system for C code, gettext.sh (or Solaris gettext(1)) for shell scripts, and libintl-perl for Perl programs. Set NO_GETTEXT to disable localization support and make Git only use English. Under autoconf the configure script will do this automatically if it can't find libintl on the system. - Python version 2.4 or later (but not 3.x, which is not supported by Perforce) is needed to use the git-p4 interface to Perforce.","title":"Git Dependencies"},{"location":"guide/3-installation/#installing-a-gui","text":"Visit https://git-scm.com/download/gui/windows for a listing of options here. I also have a listing under resources .","title":"Installing a GUI"},{"location":"guide/4-configuration/","text":"Coming soon.","title":"Configuration"}]}