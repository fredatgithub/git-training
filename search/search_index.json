{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Git Training Introduction Welcome to Git Training! The purpose of this training material is to assist those interested in learning and imlementing Git and Version Control through simple, organized procedures based on the underlying principles and concepts that lay the foundation for Git. At its core, Git is a content tracking system. While it may seem complex due to the variety of options and commands available, Git is actually quite simple. Therefore, this guide aims to elaborate on the core concepts behind Git as well as their implementation in your current workflows rather than focusing on the commands and variety of options. Vocabulary Before we dive in, there are a few terms which should be mentioned first, since they\u2019ll appear repeatedly throughout this text: repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name. Flow The usual flow of events is this: After creating a repository, your work is done in the working tree. Once your work reaches a significant point \u2014 the completion of a bug, the end of the working day, a moment when everything compiles \u2014 you add your changes successively to the index. Once the index contains everything you intend to commit, you record its content in the repository. Here\u2019s a simple diagram that shows a typical project\u2019s life-cycle: With this basic picture in mind, the following sections shall attempt to describe how each of these different entities is important to the operation of Git. Continue to Getting Started","title":"Home"},{"location":"#git-training","text":"","title":"Git Training"},{"location":"#introduction","text":"Welcome to Git Training! The purpose of this training material is to assist those interested in learning and imlementing Git and Version Control through simple, organized procedures based on the underlying principles and concepts that lay the foundation for Git. At its core, Git is a content tracking system. While it may seem complex due to the variety of options and commands available, Git is actually quite simple. Therefore, this guide aims to elaborate on the core concepts behind Git as well as their implementation in your current workflows rather than focusing on the commands and variety of options.","title":"Introduction"},{"location":"#vocabulary","text":"Before we dive in, there are a few terms which should be mentioned first, since they\u2019ll appear repeatedly throughout this text: repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name.","title":"Vocabulary"},{"location":"#flow","text":"The usual flow of events is this: After creating a repository, your work is done in the working tree. Once your work reaches a significant point \u2014 the completion of a bug, the end of the working day, a moment when everything compiles \u2014 you add your changes successively to the index. Once the index contains everything you intend to commit, you record its content in the repository. Here\u2019s a simple diagram that shows a typical project\u2019s life-cycle: With this basic picture in mind, the following sections shall attempt to describe how each of these different entities is important to the operation of Git. Continue to Getting Started","title":"Flow"},{"location":"about/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"About"},{"location":"about/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"about/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"about/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"notes/","text":"Notes: Local Workflow: git init: put Git in this folder so that it keeps track of changes to files in this folder and subfolders Working Directory: the directory you\u2019re writing code in Staging Area: files are in the staging area if the changes in them will be included in the next save point Repository: everything Git is keeping track of git status: show me which files have been changed and which ones are ready to be committed git add filename.txt: include the changes to this file in the next commit git commit -m \u201ccommit message\u201d: wrap up all these changes and save them together with a short description of the changes git log: show a history of all commits git diff: show what is different from the last commit line by line git diff 234nod: show what is different between the commit 234nod and current state, line by line Remote Repository git remote add origin address-of-remote: make address-of-remote a new place to put my code and call it \u201corigin\u201d git push -u origin master: push my code to the location origin points to, on the master branch, and also in the future I will pull code from this same location Upstream: where I will pull code from in the future Origin: where I put backups or share my code git pull: grab code from another repository git fetch: grab code from another repository git push: save my history and changes in another location Fork: I want a GitHub repo that looks like someone else\u2019s repo Pull Request: I made some changes that I would like you to include in your repository, please accept them git clone: give me the code at this location Branching git branch: what are all my branches? or what are all the names of the different versions of my code? git branch feature: make a new branch/version of my code with the name feature git checkout feature: move to that branch/version of my code so I can make changes to that branch/version of my code master: the name of the branch which should be the official, working, well documented, version of my code git merge: combine the history of two branches so I can have the changes from both in one place Merge Conflict: Git does not know how to combine two histories and needs human assistance More Advanced Concepts Would not teach these early on in the process. HEAD git rebase git rm filename.txt git mv filename.txt otherfile.txt git rebase git cherry-pick git bisect git amend git reflog git blame Tips Have trainees install Git and make a GitHub/Bitbucket account ahead of time to save time. Anticipate Windows users and be prepared for the strange ways in which Git bash works differently. Partner students up so there are fewer different machines to worry about. Make sure the partners have the same operating system so that they do not learn Git in an environment they will never use again. If you are teaching an individual, give them a project to work on so they can use Git in context. It is harder to pick a project that would work for a group of people, and it will be hard to monitor all of them, of course. But if you can use a project, especially for teaching a single person, the process is a lot easier. Don\u2019t forget Build a context for your student before teaching commands by explaining the problem Git solves, drawing pictures, and using metaphors. When you teach the commands, try and explain them without using the name of the command in the explanation. Be choosey about what to teach right now and what they can learn later.","title":"Notes"},{"location":"notes/#notes","text":"","title":"Notes:"},{"location":"notes/#local-workflow","text":"git init: put Git in this folder so that it keeps track of changes to files in this folder and subfolders Working Directory: the directory you\u2019re writing code in Staging Area: files are in the staging area if the changes in them will be included in the next save point Repository: everything Git is keeping track of git status: show me which files have been changed and which ones are ready to be committed git add filename.txt: include the changes to this file in the next commit git commit -m \u201ccommit message\u201d: wrap up all these changes and save them together with a short description of the changes git log: show a history of all commits git diff: show what is different from the last commit line by line git diff 234nod: show what is different between the commit 234nod and current state, line by line","title":"Local Workflow:"},{"location":"notes/#remote-repository","text":"git remote add origin address-of-remote: make address-of-remote a new place to put my code and call it \u201corigin\u201d git push -u origin master: push my code to the location origin points to, on the master branch, and also in the future I will pull code from this same location Upstream: where I will pull code from in the future Origin: where I put backups or share my code git pull: grab code from another repository git fetch: grab code from another repository git push: save my history and changes in another location Fork: I want a GitHub repo that looks like someone else\u2019s repo Pull Request: I made some changes that I would like you to include in your repository, please accept them git clone: give me the code at this location","title":"Remote Repository"},{"location":"notes/#branching","text":"git branch: what are all my branches? or what are all the names of the different versions of my code? git branch feature: make a new branch/version of my code with the name feature git checkout feature: move to that branch/version of my code so I can make changes to that branch/version of my code master: the name of the branch which should be the official, working, well documented, version of my code git merge: combine the history of two branches so I can have the changes from both in one place Merge Conflict: Git does not know how to combine two histories and needs human assistance","title":"Branching"},{"location":"notes/#more-advanced-concepts","text":"Would not teach these early on in the process. HEAD git rebase git rm filename.txt git mv filename.txt otherfile.txt git rebase git cherry-pick git bisect git amend git reflog git blame","title":"More Advanced Concepts"},{"location":"notes/#tips","text":"Have trainees install Git and make a GitHub/Bitbucket account ahead of time to save time. Anticipate Windows users and be prepared for the strange ways in which Git bash works differently. Partner students up so there are fewer different machines to worry about. Make sure the partners have the same operating system so that they do not learn Git in an environment they will never use again. If you are teaching an individual, give them a project to work on so they can use Git in context. It is harder to pick a project that would work for a group of people, and it will be hard to monitor all of them, of course. But if you can use a project, especially for teaching a single person, the process is a lot easier.","title":"Tips"},{"location":"notes/#dont-forget","text":"Build a context for your student before teaching commands by explaining the problem Git solves, drawing pictures, and using metaphors. When you teach the commands, try and explain them without using the name of the command in the explanation. Be choosey about what to teach right now and what they can learn later.","title":"Don\u2019t forget"},{"location":"resources/","text":"Git Resources Websites Git Website About Documentation Downloads Community Pro Git Book Learning Branching Javascript Tutorial Online Atlassian Git Tutorials Git Immersion Guided Tour Code Academy: Learn Git Article: Better Documentation through Committ Messages Article: How to write Git Committ Messages Graphical User Interface's - GUI Git GUI Visual Studio Code Sourcetree GitHub Desktop GitKraken this is what I use RStudio SmartGit GitUp Fork git-cola Git-Ahead TortoiseGit Tower Sublime Merge Gitg Aurees GitAtomic and many others! Glossary repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name. Commands Concepts","title":"Resources"},{"location":"resources/#git-resources","text":"","title":"Git Resources"},{"location":"resources/#websites","text":"Git Website About Documentation Downloads Community Pro Git Book Learning Branching Javascript Tutorial Online Atlassian Git Tutorials Git Immersion Guided Tour Code Academy: Learn Git Article: Better Documentation through Committ Messages Article: How to write Git Committ Messages","title":"Websites"},{"location":"resources/#graphical-user-interfaces-gui","text":"Git GUI Visual Studio Code Sourcetree GitHub Desktop GitKraken this is what I use RStudio SmartGit GitUp Fork git-cola Git-Ahead TortoiseGit Tower Sublime Merge Gitg Aurees GitAtomic and many others!","title":"Graphical User Interface's - GUI"},{"location":"resources/#glossary","text":"repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name.","title":"Glossary"},{"location":"resources/#commands","text":"","title":"Commands"},{"location":"resources/#concepts","text":"","title":"Concepts"},{"location":"guide/0-introduction/","text":"Introduction Welcome to Git! The purpose of this training material is to assist those interested in learning and imlementing Git and Version Control through simple, organized procedures based on the underlying principles and concepts that lay the foundation for Git. At its core, Git is a content tracking system. While it may seem complex due to the variety of options and commands available, Git is actually quite simple. Therefore, this guide aims to elaborate on the core concepts behind Git as well as their implementation in your current workflows rather than focusing on the commands and variety of options. Vocabulary Before we dive in, there are a few terms which should be mentioned first, since they\u2019ll appear repeatedly throughout this text: repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name. Flow The usual flow of events is this: After creating a repository, your work is done in the working tree. Once your work reaches a significant point \u2014 the completion of a bug, the end of the working day, a moment when everything compiles \u2014 you add your changes successively to the index. Once the index contains everything you intend to commit, you record its content in the repository. Here\u2019s a simple diagram that shows a typical project\u2019s life-cycle: With this basic picture in mind, the following sections shall attempt to describe how each of these different entities is important to the operation of Git. Continue to Getting Started","title":"Introduction"},{"location":"guide/0-introduction/#introduction","text":"Welcome to Git! The purpose of this training material is to assist those interested in learning and imlementing Git and Version Control through simple, organized procedures based on the underlying principles and concepts that lay the foundation for Git. At its core, Git is a content tracking system. While it may seem complex due to the variety of options and commands available, Git is actually quite simple. Therefore, this guide aims to elaborate on the core concepts behind Git as well as their implementation in your current workflows rather than focusing on the commands and variety of options.","title":"Introduction"},{"location":"guide/0-introduction/#vocabulary","text":"Before we dive in, there are a few terms which should be mentioned first, since they\u2019ll appear repeatedly throughout this text: repository \u2014 A repository is a collection of commits, each of which is an archive of what the project\u2019s working tree looked like at a past date, whether on your machine or someone else\u2019s. It also defines HEAD (see below), which identifies the branch or commit the current working tree stemmed from. Lastly, it contains a set of branches and tags, to identify certain commits by name. the index \u2014 Unlike other, similar tools you may have used, Git does not commit changes directly from the working tree into the repository. Instead, changes are first registered in something called the index. Think of it as a way of \u201cconfirming\u201d your changes, one by one, before doing a commit (which records all your approved changes at once). Some find it helpful to call it instead as the \u201cstaging area\u201d, instead of the index. working tree \u2014 A working tree is any directory on your filesystem which has a repository associated with it (typically indicated by the presence of a sub-directory within it named .git.). It includes all the files and sub-directories in that directory. commit \u2014 A commit is a snapshot of your working tree at some point in time. The state of HEAD (see below) at the time your commit is made becomes that commit\u2019s parent. This is what creates the notion of a \u201crevision history\u201d. branch \u2014 A branch is just a name for a commit (and much more will be said about commits in a moment), also called a reference. It\u2019s the parentage of a commit which defines its history, and thus the typical notion of a \u201cbranch of development\u201d. tag \u2014 A tag is also a name for a commit, similar to a branch, except that it always names the same commit, and can have its own description text. master \u2014 The mainline of development in most repositories is done on a branch called \u201c master \u201d. Although this is a typical default, it is in no way special. HEAD \u2014 HEAD is used by your repository to define what is currently checked out: If you checkout a branch, HEAD symbolically refers to that branch, indicating that the branch name should be updated after the next commit operation. If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a detached HEAD, and occurs, for example, if you check out a tag name.","title":"Vocabulary"},{"location":"guide/0-introduction/#flow","text":"The usual flow of events is this: After creating a repository, your work is done in the working tree. Once your work reaches a significant point \u2014 the completion of a bug, the end of the working day, a moment when everything compiles \u2014 you add your changes successively to the index. Once the index contains everything you intend to commit, you record its content in the repository. Here\u2019s a simple diagram that shows a typical project\u2019s life-cycle: With this basic picture in mind, the following sections shall attempt to describe how each of these different entities is important to the operation of Git. Continue to Getting Started","title":"Flow"},{"location":"guide/1-getting-started/","text":"Getting Started When first getting started with Git it is useful to first understand the core concepts and workflows related to Git and Version Control Systems. Here I will first look at those core concepts and workflows and then follow up with a more in-depth dive into the individual components that build the Version Control System. Core Concepts and Workflows At its core Git is merely a content magement system build off of comprehensive indexing the history, changes, and metadata surrounding the evolutionof those changes over time for a specific project, dataset, or directory of content. Distributed Version Control System It is important to realize that a distributed version control system is the backbone of the fundamental Git workflow. To understand further imagine separating your project into two main environments: The Dev Environment - This is where you work on your project locally and develop new code, data, functions, etc. The Remote or Server Environment - This is a remote repository that mirrors and tracks your development environment using Git. The Development Environment: Working Directory Staging Area and Index Local Repository Server / Remote Environment: Remote Repository Cloning When cloning a remote repository, the data from the remote repository travels to two areas: Working Directory Local Repository Making Changes There are two types of files in the working directory: Tracked: files that Git knows about. Untracked: files that have still not been added, so Git doesn\u2019t know about. Updating the Remote Repository As changes are ready in the working directory, they must be added in the staging area. When there is a set of changes with a single purpose in the staging area, it\u2019s the time to create a commit with a message about that purpose in the local repository. When there are one or several commits in the local repository ready to be shared with the rest of the world, they must be pushed to the remote repository. The core workflow for incorporating changes from local to remote is Add -> Commit -> Push : You can break down the different possible states of a file in the development environment into three main categories: Modified Staged Committed Additionally, it is useful to be familiar with these helpful utility commands: git diff - show the changes of a file in the working directory compared to what is currently on remote. git diff --staged - show the changes of a file in the staging area Updating the Development Environment When changes are made on the remote repository over time, either by yourself or collaborators, you will want to keep your local development environment up-to-date by fetching , pulling , and/or rebasing the remote repository with your local repository. A helpful way to think about this is imagining it working like cloud storage software such as Google Drive. When a file is updated on the cloud (i.e. the remote repository) the software sync's your local version of that file to stay up-to-date with the remote file. Similarly, Git keeps your local environment in sync by continuously watching and tracking changes to the remote repository, but will not automatically make the changes to your local repository for you. Fetching Fetching via git fetch pulls data from the remote repository to the local repository . Pulling When executing git pull , the data from remote repository travel to two areas: To local repository: fetch To working directory: merge Rebasing If you take care of the commit history, consider the use of git pull --rebase . Instead of fetch + merge, it consists of fetch + rebase. Your local commits will be replayed and you won\u2019t see the known diamond shape in commit history. Additional Concepts Stashing Branching Commit history Further Reading Pro Git Book Now lets take an in-depth look at git from the ground up by continuing to Git Deep Dive","title":"Getting Started"},{"location":"guide/1-getting-started/#getting-started","text":"When first getting started with Git it is useful to first understand the core concepts and workflows related to Git and Version Control Systems. Here I will first look at those core concepts and workflows and then follow up with a more in-depth dive into the individual components that build the Version Control System.","title":"Getting Started"},{"location":"guide/1-getting-started/#core-concepts-and-workflows","text":"At its core Git is merely a content magement system build off of comprehensive indexing the history, changes, and metadata surrounding the evolutionof those changes over time for a specific project, dataset, or directory of content.","title":"Core Concepts and Workflows"},{"location":"guide/1-getting-started/#distributed-version-control-system","text":"It is important to realize that a distributed version control system is the backbone of the fundamental Git workflow. To understand further imagine separating your project into two main environments: The Dev Environment - This is where you work on your project locally and develop new code, data, functions, etc. The Remote or Server Environment - This is a remote repository that mirrors and tracks your development environment using Git.","title":"Distributed Version Control System"},{"location":"guide/1-getting-started/#the-development-environment","text":"Working Directory Staging Area and Index Local Repository","title":"The Development Environment:"},{"location":"guide/1-getting-started/#server-remote-environment","text":"Remote Repository","title":"Server / Remote Environment:"},{"location":"guide/1-getting-started/#cloning","text":"When cloning a remote repository, the data from the remote repository travels to two areas: Working Directory Local Repository","title":"Cloning"},{"location":"guide/1-getting-started/#making-changes","text":"There are two types of files in the working directory: Tracked: files that Git knows about. Untracked: files that have still not been added, so Git doesn\u2019t know about.","title":"Making Changes"},{"location":"guide/1-getting-started/#updating-the-remote-repository","text":"As changes are ready in the working directory, they must be added in the staging area. When there is a set of changes with a single purpose in the staging area, it\u2019s the time to create a commit with a message about that purpose in the local repository. When there are one or several commits in the local repository ready to be shared with the rest of the world, they must be pushed to the remote repository. The core workflow for incorporating changes from local to remote is Add -> Commit -> Push : You can break down the different possible states of a file in the development environment into three main categories: Modified Staged Committed Additionally, it is useful to be familiar with these helpful utility commands: git diff - show the changes of a file in the working directory compared to what is currently on remote. git diff --staged - show the changes of a file in the staging area","title":"Updating the Remote Repository"},{"location":"guide/1-getting-started/#updating-the-development-environment","text":"When changes are made on the remote repository over time, either by yourself or collaborators, you will want to keep your local development environment up-to-date by fetching , pulling , and/or rebasing the remote repository with your local repository. A helpful way to think about this is imagining it working like cloud storage software such as Google Drive. When a file is updated on the cloud (i.e. the remote repository) the software sync's your local version of that file to stay up-to-date with the remote file. Similarly, Git keeps your local environment in sync by continuously watching and tracking changes to the remote repository, but will not automatically make the changes to your local repository for you.","title":"Updating the Development Environment"},{"location":"guide/1-getting-started/#fetching","text":"Fetching via git fetch pulls data from the remote repository to the local repository .","title":"Fetching"},{"location":"guide/1-getting-started/#pulling","text":"When executing git pull , the data from remote repository travel to two areas: To local repository: fetch To working directory: merge","title":"Pulling"},{"location":"guide/1-getting-started/#rebasing","text":"If you take care of the commit history, consider the use of git pull --rebase . Instead of fetch + merge, it consists of fetch + rebase. Your local commits will be replayed and you won\u2019t see the known diamond shape in commit history.","title":"Rebasing"},{"location":"guide/1-getting-started/#additional-concepts","text":"Stashing Branching Commit history","title":"Additional Concepts"},{"location":"guide/1-getting-started/#further-reading","text":"Pro Git Book Now lets take an in-depth look at git from the ground up by continuing to Git Deep Dive","title":"Further Reading"},{"location":"guide/2-deep-dive/","text":"Coming Soon.","title":"Deep Dive"},{"location":"guide/3-installation/","text":"Coming Soon.","title":"Installation"},{"location":"guide/4-configuration/","text":"Coming soon.","title":"Configuration"}]}